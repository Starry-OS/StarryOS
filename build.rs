use std::path::PathBuf;

fn main() {
    // Only apply bare-metal linker settings when targeting a no_std platform.
    // This allows `cargo xtask` (which builds for the host) and `cargo publish`
    // verification to succeed without linker errors.
    let target = std::env::var("TARGET").unwrap_or_default();
    if !target.contains("-none") {
        return;
    }

    // The linker script is generated by axhal's build.rs at:
    //   target/<target_triple>/<profile>/linker_<platform>.lds
    // We can locate it relative to OUT_DIR:
    //   OUT_DIR = target/<triple>/<profile>/build/<pkg>-<hash>/out
    //   ../../.. from OUT_DIR = target/<triple>/<profile>/
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let profile_dir = PathBuf::from(&out_dir).join("../../..");
    let profile_dir = std::fs::canonicalize(&profile_dir)
        .unwrap_or_else(|_| PathBuf::from(&out_dir).join("../../.."));

    // Use AX_PLATFORM env var if set (from xtask), otherwise auto-detect from architecture
    let arch = std::env::var("CARGO_CFG_TARGET_ARCH").unwrap();
    let platform = std::env::var("AX_PLATFORM").unwrap_or_else(|_| {
        match arch.as_str() {
            "riscv64" => "riscv64-qemu-virt",
            "aarch64" => "aarch64-qemu-virt",
            "x86_64" => "x86-pc",
            "loongarch64" => "loongarch64-qemu-virt",
            other => panic!("Unsupported architecture: {other}"),
        }
        .to_string()
    });
    let lds_path = profile_dir.join(format!("linker_{platform}.lds"));

    println!("cargo:rustc-link-arg=-T{}", lds_path.display());
    println!("cargo:rustc-link-arg=-no-pie");
    println!("cargo:rustc-link-arg=-znostart-stop-gc");
    println!("cargo:rerun-if-env-changed=AX_PLATFORM");
}
